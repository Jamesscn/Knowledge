{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Knowledge is Power \"Skill to do comes of doing; knowledge comes by eyes always open, and working hands; and there is no knowledge that is not power.\" - Ralph Waldo Emerson Welcome to my knowledge sharing website, where you can find miscellaneous tutorials, guides and other material on topics I have experience with. I decided to make this website to give something back to the world because most of the knowledge I have acquired has come from websites, videos and other excellent internet resources. If you have any suggestions, comments or other matters, feel free to reach out to me at my personal email: jamesscn@gmail.com","title":"Knowledge is Power"},{"location":"#knowledge-is-power","text":"\"Skill to do comes of doing; knowledge comes by eyes always open, and working hands; and there is no knowledge that is not power.\" - Ralph Waldo Emerson Welcome to my knowledge sharing website, where you can find miscellaneous tutorials, guides and other material on topics I have experience with. I decided to make this website to give something back to the world because most of the knowledge I have acquired has come from websites, videos and other excellent internet resources. If you have any suggestions, comments or other matters, feel free to reach out to me at my personal email: jamesscn@gmail.com","title":"Knowledge is Power"},{"location":"yocto/","text":"Making a Linux Distribution for Raspberry Pi This tutorial will cover how to create an embedded Linux distribution with the bare minimum installed using the Yocto Project for the Raspberry Pi 4. While there are other tutorials out there, I have found them to be vague, and some of them require you to download special tools in order to actually make the distribution. This tutorial focuses on the Raspberry Pi 4 because it is one of the more commercially available embedded boards capable of running Linux (at least at the time of this writing). That being said, most of the information presented can be extrapolated to build a distribution for another board given that a board support package for it exists. What is a Linux Distribution? By Linux distribution, I am referring to the combination of the Linux kernel (the core of Linux, which allows programs to interact with the system's hardware) and a set of packages, which are programs which run upon the Linux kernel such as bash, gcc and python. Why make a Linux Distribution? The main reasons for building a Linux distribution are to either to gain a better understanding of how Linux works, or to port Linux to a customly designed embedded device with strict requirements which you can control. Apart from these reasons, given that there are many distributions with extremely strong support that can be installed on just about any system, there is little need to build a distribution. Nevertheless, I still find the idea of creating a Linux distribution fun, therefore I have decided to create this tutorial. Other Resources If you are looking for other material to complement this tutorial, or are simply looking for something else, these resources may be good for you. I thoroughly recommend Digikey's series on building an embedded Linux distribution, as it covers the material presented in this tutorial and more: Introduction to Embedded Linux . It is different to this tutorial in that a STM32MP157D-DK1 board is used instead of the Raspberry Pi 4, which is slightly harder to acquire. I also heavily recommend taking a look at Bootlin's slides on Yocto, as they are very informative and explain Yocto in much greater detail: Yocto Project and OpenEmbedded system development training","title":"Making a Linux Distribution for Raspberry Pi"},{"location":"yocto/#making-a-linux-distribution-for-raspberry-pi","text":"This tutorial will cover how to create an embedded Linux distribution with the bare minimum installed using the Yocto Project for the Raspberry Pi 4. While there are other tutorials out there, I have found them to be vague, and some of them require you to download special tools in order to actually make the distribution. This tutorial focuses on the Raspberry Pi 4 because it is one of the more commercially available embedded boards capable of running Linux (at least at the time of this writing). That being said, most of the information presented can be extrapolated to build a distribution for another board given that a board support package for it exists.","title":"Making a Linux Distribution for Raspberry Pi"},{"location":"yocto/#what-is-a-linux-distribution","text":"By Linux distribution, I am referring to the combination of the Linux kernel (the core of Linux, which allows programs to interact with the system's hardware) and a set of packages, which are programs which run upon the Linux kernel such as bash, gcc and python.","title":"What is a Linux Distribution?"},{"location":"yocto/#why-make-a-linux-distribution","text":"The main reasons for building a Linux distribution are to either to gain a better understanding of how Linux works, or to port Linux to a customly designed embedded device with strict requirements which you can control. Apart from these reasons, given that there are many distributions with extremely strong support that can be installed on just about any system, there is little need to build a distribution. Nevertheless, I still find the idea of creating a Linux distribution fun, therefore I have decided to create this tutorial.","title":"Why make a Linux Distribution?"},{"location":"yocto/#other-resources","text":"If you are looking for other material to complement this tutorial, or are simply looking for something else, these resources may be good for you. I thoroughly recommend Digikey's series on building an embedded Linux distribution, as it covers the material presented in this tutorial and more: Introduction to Embedded Linux . It is different to this tutorial in that a STM32MP157D-DK1 board is used instead of the Raspberry Pi 4, which is slightly harder to acquire. I also heavily recommend taking a look at Bootlin's slides on Yocto, as they are very informative and explain Yocto in much greater detail: Yocto Project and OpenEmbedded system development training","title":"Other Resources"},{"location":"yocto/about-yocto/","text":"About the Yocto Project What exactly is the Yocto Project? Yocto is a tool used to create Linux distributions for embedded devices with ease. In the past, making a Linux distribution was an incredibly hard feat for several reasons, such as the fact that a considerably large amount of work had to be done to build the distribution and support it across different architectures, and the fact that programmers needed a ridiculously large amount of knowledge to understand how every small component works. However, with Yocto anyone can create a Linux distribution from their home computer or laptop by downloading the necessary components and configuring them in a matter of hours. One of the advantages of Yocto is that if you build a distribution and decide to make a small change, it only needs to compile that change because it keeps its progress, saving you a lot of time. Yocto uses layers and recipes in order to create a Linux distribution. A recipe is essentially a script which tells Yocto how to install a package or program on the system, telling it where to download the package, where to put it, how to compile it and any other necessary steps. A layer is a group of recipes, and each layer usually holds recipes related to a specific purpose or functionality. For example, a common layer is the meta-networking layer from the OpenEmbedded core. This layer holds recipes for many networking related packages. Yocto is build up of three core components that will be mentioned in the next steps. These three components are the following: Poky : It is a reference system or a blank template with a bunch of useful tools. OpenEmbedded core : A set of layers containing basic packages which are common in most Linux distributions. Bitbake : A powerful script which builds everything, from individual packages up to the entire distribution. Together, these three components make up the Yocto project.","title":"About the Yocto Project"},{"location":"yocto/about-yocto/#about-the-yocto-project","text":"","title":"About the Yocto Project"},{"location":"yocto/about-yocto/#what-exactly-is-the-yocto-project","text":"Yocto is a tool used to create Linux distributions for embedded devices with ease. In the past, making a Linux distribution was an incredibly hard feat for several reasons, such as the fact that a considerably large amount of work had to be done to build the distribution and support it across different architectures, and the fact that programmers needed a ridiculously large amount of knowledge to understand how every small component works. However, with Yocto anyone can create a Linux distribution from their home computer or laptop by downloading the necessary components and configuring them in a matter of hours. One of the advantages of Yocto is that if you build a distribution and decide to make a small change, it only needs to compile that change because it keeps its progress, saving you a lot of time. Yocto uses layers and recipes in order to create a Linux distribution. A recipe is essentially a script which tells Yocto how to install a package or program on the system, telling it where to download the package, where to put it, how to compile it and any other necessary steps. A layer is a group of recipes, and each layer usually holds recipes related to a specific purpose or functionality. For example, a common layer is the meta-networking layer from the OpenEmbedded core. This layer holds recipes for many networking related packages. Yocto is build up of three core components that will be mentioned in the next steps. These three components are the following: Poky : It is a reference system or a blank template with a bunch of useful tools. OpenEmbedded core : A set of layers containing basic packages which are common in most Linux distributions. Bitbake : A powerful script which builds everything, from individual packages up to the entire distribution. Together, these three components make up the Yocto project.","title":"What exactly is the Yocto Project?"},{"location":"yocto/building-images/","text":"Building an Image with Bitbake Note Building a Yocto distribution is very resource heavy and usually takes several hours to complete depending on your computer's processing power and your network connection, even while doing a minimal build. Furthermore, builds can occupy anywhere from 50 to 200 GB of space on your hard drive, so make sure you are ready for this before you start the build. You are just about ready to start building your Linux distribution. There are several different targets or builds that can be done, ranging from minimal builds to toolchain-specific builds and more. In our case we are only currently interested in a minimal build, so we will run the following command. The command will likely take several hours to run and does not require you to answer any prompts, so I recommend you leave it running and ocasionally check back every now and then: bitbake core-image-minimal Once the build has completed you should be able to see a bunch of files in the build/tmp/deploy/images/ folder. This folder holds your generated image. The image we are interested in is the one named core-image-base-raspberrypi4.rpi-sdimg .","title":"Building an Image with Bitbake"},{"location":"yocto/building-images/#building-an-image-with-bitbake","text":"Note Building a Yocto distribution is very resource heavy and usually takes several hours to complete depending on your computer's processing power and your network connection, even while doing a minimal build. Furthermore, builds can occupy anywhere from 50 to 200 GB of space on your hard drive, so make sure you are ready for this before you start the build. You are just about ready to start building your Linux distribution. There are several different targets or builds that can be done, ranging from minimal builds to toolchain-specific builds and more. In our case we are only currently interested in a minimal build, so we will run the following command. The command will likely take several hours to run and does not require you to answer any prompts, so I recommend you leave it running and ocasionally check back every now and then: bitbake core-image-minimal Once the build has completed you should be able to see a bunch of files in the build/tmp/deploy/images/ folder. This folder holds your generated image. The image we are interested in is the one named core-image-base-raspberrypi4.rpi-sdimg .","title":"Building an Image with Bitbake"},{"location":"yocto/flashing-images/","text":"Flashing the Image to the Micro-SD Card Now that you have created your image, the next step is to burn it onto the Micro-SD card. Make sure to connect it to the Micro-SD to SD adapter and plug it into your computer. Once you have done this should be able to see the card. Be certain that you have moved any important information off of the Micro-SD card before proceeding, because we will be overwriting the data on the card with the image. The next step is to determine where your device is loaded in the /dev/ folder. This can be done in several ways, and I recommend using a graphical program such as GParted to verify that you are looking at the correct device. The easiest way to do this though is to run the lsblk command before plugging in the Micro-SD card and after doing so. Here, I am showing the output of the command before plugging in the Micro-SD card: $ lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS sda 8:0 0 931.5G 0 disk \u251c\u2500sda1 8:1 0 286.2G 0 part / \u251c\u2500sda2 8:2 0 16.1G 0 part [SWAP] \u2514\u2500sda3 8:3 0 629.3G 0 part nvme0n1 259:0 0 238.5G 0 disk \u251c\u2500nvme0n1p1 259:1 0 250M 0 part \u251c\u2500nvme0n1p2 259:2 0 128M 0 part \u251c\u2500nvme0n1p3 259:3 0 218.8G 0 part \u251c\u2500nvme0n1p4 259:4 0 990M 0 part \u251c\u2500nvme0n1p5 259:5 0 17G 0 part \u2514\u2500nvme0n1p6 259:6 0 1.4G 0 part And after plugging it in this is what is shown: $ lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS sda 8:0 0 931.5G 0 disk \u251c\u2500sda1 8:1 0 286.2G 0 part / \u251c\u2500sda2 8:2 0 16.1G 0 part [SWAP] \u2514\u2500sda3 8:3 0 629.3G 0 part sdb 8:16 1 58G 0 disk \u251c\u2500sdb1 8:17 1 40M 0 part \u2514\u2500sdb2 8:18 1 144M 0 part nvme0n1 259:0 0 238.5G 0 disk \u251c\u2500nvme0n1p1 259:1 0 250M 0 part \u251c\u2500nvme0n1p2 259:2 0 128M 0 part \u251c\u2500nvme0n1p3 259:3 0 218.8G 0 part \u251c\u2500nvme0n1p4 259:4 0 990M 0 part \u251c\u2500nvme0n1p5 259:5 0 17G 0 part \u2514\u2500nvme0n1p6 259:6 0 1.4G 0 part You can see that a new device, sdb , has now appeared with a size of 58 GB. This is close to the 64 GB of capacity my Micro-SD card is supposed to hold, therefore I am quite certain that my Micro-SD card is mounted at /dev/sdb. However it is very important that you run these commands on your machine and verify where your Micro-SD card is mounted, because this can change even on the same computer . If you overwrite /dev/sdb without verifying that your Micro-SD card is there, it may lead to a catastrophic loss of data . Now that you have determined where to write the data to, you can proceed to use the dd command to start writing your image to the Micro-SD card. In the next steps I will be using /dev/sdX as the place where the Micro-SD card is mounted at. Remember that you have to change this to the place where you have your Micro-SD card. Warning! The dd command is extremely dangerous and can permanently delete your hard drive . Make sure you are overwriting the correct device. In order to write the image to the Micro-SD card, run the following commands from the build/ directory, replacing all instances of /dev/sdX . sudo umount /dev/sdX sudo dd if=tmp/deploy/images/raspberrypi4/core-image-base-raspberrypi4.rpi-sdimg of=/dev/sdX sync sudo umount /dev/sdX After this, your Micro-SD card should have two partitions, one with a bunch of .dat and .elf files and another with the actual filesystem of your image. You should now be able to connect your Micro-SD card to the Raspberry Pi and run your custom Linux distribution.","title":"Flashing the Image to the Micro-SD Card"},{"location":"yocto/flashing-images/#flashing-the-image-to-the-micro-sd-card","text":"Now that you have created your image, the next step is to burn it onto the Micro-SD card. Make sure to connect it to the Micro-SD to SD adapter and plug it into your computer. Once you have done this should be able to see the card. Be certain that you have moved any important information off of the Micro-SD card before proceeding, because we will be overwriting the data on the card with the image. The next step is to determine where your device is loaded in the /dev/ folder. This can be done in several ways, and I recommend using a graphical program such as GParted to verify that you are looking at the correct device. The easiest way to do this though is to run the lsblk command before plugging in the Micro-SD card and after doing so. Here, I am showing the output of the command before plugging in the Micro-SD card: $ lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS sda 8:0 0 931.5G 0 disk \u251c\u2500sda1 8:1 0 286.2G 0 part / \u251c\u2500sda2 8:2 0 16.1G 0 part [SWAP] \u2514\u2500sda3 8:3 0 629.3G 0 part nvme0n1 259:0 0 238.5G 0 disk \u251c\u2500nvme0n1p1 259:1 0 250M 0 part \u251c\u2500nvme0n1p2 259:2 0 128M 0 part \u251c\u2500nvme0n1p3 259:3 0 218.8G 0 part \u251c\u2500nvme0n1p4 259:4 0 990M 0 part \u251c\u2500nvme0n1p5 259:5 0 17G 0 part \u2514\u2500nvme0n1p6 259:6 0 1.4G 0 part And after plugging it in this is what is shown: $ lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTS sda 8:0 0 931.5G 0 disk \u251c\u2500sda1 8:1 0 286.2G 0 part / \u251c\u2500sda2 8:2 0 16.1G 0 part [SWAP] \u2514\u2500sda3 8:3 0 629.3G 0 part sdb 8:16 1 58G 0 disk \u251c\u2500sdb1 8:17 1 40M 0 part \u2514\u2500sdb2 8:18 1 144M 0 part nvme0n1 259:0 0 238.5G 0 disk \u251c\u2500nvme0n1p1 259:1 0 250M 0 part \u251c\u2500nvme0n1p2 259:2 0 128M 0 part \u251c\u2500nvme0n1p3 259:3 0 218.8G 0 part \u251c\u2500nvme0n1p4 259:4 0 990M 0 part \u251c\u2500nvme0n1p5 259:5 0 17G 0 part \u2514\u2500nvme0n1p6 259:6 0 1.4G 0 part You can see that a new device, sdb , has now appeared with a size of 58 GB. This is close to the 64 GB of capacity my Micro-SD card is supposed to hold, therefore I am quite certain that my Micro-SD card is mounted at /dev/sdb. However it is very important that you run these commands on your machine and verify where your Micro-SD card is mounted, because this can change even on the same computer . If you overwrite /dev/sdb without verifying that your Micro-SD card is there, it may lead to a catastrophic loss of data . Now that you have determined where to write the data to, you can proceed to use the dd command to start writing your image to the Micro-SD card. In the next steps I will be using /dev/sdX as the place where the Micro-SD card is mounted at. Remember that you have to change this to the place where you have your Micro-SD card. Warning! The dd command is extremely dangerous and can permanently delete your hard drive . Make sure you are overwriting the correct device. In order to write the image to the Micro-SD card, run the following commands from the build/ directory, replacing all instances of /dev/sdX . sudo umount /dev/sdX sudo dd if=tmp/deploy/images/raspberrypi4/core-image-base-raspberrypi4.rpi-sdimg of=/dev/sdX sync sudo umount /dev/sdX After this, your Micro-SD card should have two partitions, one with a bunch of .dat and .elf files and another with the actual filesystem of your image. You should now be able to connect your Micro-SD card to the Raspberry Pi and run your custom Linux distribution.","title":"Flashing the Image to the Micro-SD Card"},{"location":"yocto/initial-config/","text":"Configuring Yocto There are two main files which will be configured, the bblayers.conf file and the local.conf file. The bblayers.conf file is used to tell Yocto which layers will be used and where they are located, and the local.conf file is used for more general configuration, such as telling Yocto what type of system its building and where to store things. Layer Configuration First, open the bblayers.conf file, which should have the following or similar contents: # POKY_BBLAYERS_CONF_VERSION is increased each time build/conf/bblayers.conf # changes incompatibly POKY_BBLAYERS_CONF_VERSION = \"2\" BBPATH = \"${TOPDIR}\" BBFILES ?= \"\" BBLAYERS ?= \" \\ /home/your_username/Documents/Yocto/poky/meta \\ /home/your_username/Documents/Yocto/poky/meta-poky \\ /home/your_username/Documents/Yocto/poky/meta-yocto-bsp \\ \" The part we are interested in is the BBLAYERS variable, which is a list of directories representing the layers to be installed. Currently, the meta, meta-poky and meta-yocto-bsp layers from Poky have been added. You now need to install some of the layers from the OpenEmbedded repository that was downloaded in the previous step because they serve as dependencies. Taking a look at the Yocto/meta-openembedded folder we can see there are many layers that can be added: $ ls ~/Documents/Yocto/meta-openembedded COPYING.MIT meta-filesystems meta-multimedia meta-perl meta-xfce README meta-gnome meta-networking meta-python contrib meta-initramfs meta-oe meta-webserver The only necessary layer is the meta-oe layer, however if you want more features you can add the other folders as well to the BBLAYERS variable. You can paste the (absolute!) path to the meta-oe directory into our BBLAYERS variable as follows: BBLAYERS ?= \" \\ /home/your_username/Documents/Yocto/poky/meta \\ /home/your_username/Documents/Yocto/poky/meta-poky \\ /home/your_username/Documents/Yocto/poky/meta-yocto-bsp \\ /home/your_username/Documents/Yocto/meta-openembedded/meta-oe \\ \" However you are not done yet, you still need to add the layer which contains the board support package for the Raspberry Pi 4, which is found in the Yocto/meta-raspberrypi folder: BBLAYERS ?= \" \\ /home/your_username/Documents/Yocto/poky/meta \\ /home/your_username/Documents/Yocto/poky/meta-poky \\ /home/your_username/Documents/Yocto/poky/meta-yocto-bsp \\ /home/your_username/Documents/Yocto/meta-openembedded/meta-oe \\ /home/your_username/Documents/Yocto/meta-raspberrypi \\ \" With this, you have now told Yocto which layers you are going to use. You can confirm that these layers have been added correctly by running the following command. If no errors appear and you can see all the layers in the BBLAYERS variable then everything should be okay. bitbake-layers show-layers Editing local.conf The next step is to edit the local.conf file. The main thing that needs to be changed here is the MACHINE variable, because this tells Yocto what type of architecture it is dealing with. What you need to do is to set the MACHINE variable the value raspberrypi4 . I recommend you place this line at the top of the file: MACHINE ?= \"raspberrypi4\" Next, if you are going to build the distribution to an SD or micro-SD card, then you also need to add this line, which will generate an image which can be easily put on the SD card: IMAGE_FSTYPES = \"rpi-sdimg\" That's just about everything you need to do in order to configure Yocto. You can play around with the settings in the local.conf file, just be careful not to break anything!","title":"Configuring Yocto"},{"location":"yocto/initial-config/#configuring-yocto","text":"There are two main files which will be configured, the bblayers.conf file and the local.conf file. The bblayers.conf file is used to tell Yocto which layers will be used and where they are located, and the local.conf file is used for more general configuration, such as telling Yocto what type of system its building and where to store things.","title":"Configuring Yocto"},{"location":"yocto/initial-config/#layer-configuration","text":"First, open the bblayers.conf file, which should have the following or similar contents: # POKY_BBLAYERS_CONF_VERSION is increased each time build/conf/bblayers.conf # changes incompatibly POKY_BBLAYERS_CONF_VERSION = \"2\" BBPATH = \"${TOPDIR}\" BBFILES ?= \"\" BBLAYERS ?= \" \\ /home/your_username/Documents/Yocto/poky/meta \\ /home/your_username/Documents/Yocto/poky/meta-poky \\ /home/your_username/Documents/Yocto/poky/meta-yocto-bsp \\ \" The part we are interested in is the BBLAYERS variable, which is a list of directories representing the layers to be installed. Currently, the meta, meta-poky and meta-yocto-bsp layers from Poky have been added. You now need to install some of the layers from the OpenEmbedded repository that was downloaded in the previous step because they serve as dependencies. Taking a look at the Yocto/meta-openembedded folder we can see there are many layers that can be added: $ ls ~/Documents/Yocto/meta-openembedded COPYING.MIT meta-filesystems meta-multimedia meta-perl meta-xfce README meta-gnome meta-networking meta-python contrib meta-initramfs meta-oe meta-webserver The only necessary layer is the meta-oe layer, however if you want more features you can add the other folders as well to the BBLAYERS variable. You can paste the (absolute!) path to the meta-oe directory into our BBLAYERS variable as follows: BBLAYERS ?= \" \\ /home/your_username/Documents/Yocto/poky/meta \\ /home/your_username/Documents/Yocto/poky/meta-poky \\ /home/your_username/Documents/Yocto/poky/meta-yocto-bsp \\ /home/your_username/Documents/Yocto/meta-openembedded/meta-oe \\ \" However you are not done yet, you still need to add the layer which contains the board support package for the Raspberry Pi 4, which is found in the Yocto/meta-raspberrypi folder: BBLAYERS ?= \" \\ /home/your_username/Documents/Yocto/poky/meta \\ /home/your_username/Documents/Yocto/poky/meta-poky \\ /home/your_username/Documents/Yocto/poky/meta-yocto-bsp \\ /home/your_username/Documents/Yocto/meta-openembedded/meta-oe \\ /home/your_username/Documents/Yocto/meta-raspberrypi \\ \" With this, you have now told Yocto which layers you are going to use. You can confirm that these layers have been added correctly by running the following command. If no errors appear and you can see all the layers in the BBLAYERS variable then everything should be okay. bitbake-layers show-layers","title":"Layer Configuration"},{"location":"yocto/initial-config/#editing-localconf","text":"The next step is to edit the local.conf file. The main thing that needs to be changed here is the MACHINE variable, because this tells Yocto what type of architecture it is dealing with. What you need to do is to set the MACHINE variable the value raspberrypi4 . I recommend you place this line at the top of the file: MACHINE ?= \"raspberrypi4\" Next, if you are going to build the distribution to an SD or micro-SD card, then you also need to add this line, which will generate an image which can be easily put on the SD card: IMAGE_FSTYPES = \"rpi-sdimg\" That's just about everything you need to do in order to configure Yocto. You can play around with the settings in the local.conf file, just be careful not to break anything!","title":"Editing local.conf"},{"location":"yocto/next-steps/","text":"Next Steps Customizing the Kernel Now that you have built your custom Linux distribution, you can add or remove whatever you want. One of the most important parts of the build is the actual Linux kernel. You can control the kernel by running the menuconfig script, which will allow you to enable, disable or turn certain features into kernel modules. To run the menuconfig script, ensure you are in the build environment and run the following command: bitbake -c menuconfig virtual/kernel After running this command, a .config file should be generated stating all of your customizations. Adding Packages and Layers As stated earlier, you can visit the OpenEmbedded Layers Index to find more layers with packages you can install onto your system. Don't forget that the OpenEmbedded repository also has some layers which we haven't included yet! Once you add a layer which contains the packages you want to install to the BBLAYERS variable, you can add the following line to your local.conf file, replacing the packages below with the names of the packages you want to install. Just make sure to conserve the space before and between each of the package names. IMAGE_INSTALL_append = \" package1 package2 package3\" If you can't find a particular package, you can even create your own Yocto layer and create a recipe which will download and install that package. Just be aware that things can get a bit complicated with this method, so it is preferrable to use an existing layer if possible. While I have not found a good tutorial on how to create a layer, the following one explains very briefly how to create a layer and a recipe for a kernel module: Yocto: Create a New Layer","title":"Next Steps"},{"location":"yocto/next-steps/#next-steps","text":"","title":"Next Steps"},{"location":"yocto/next-steps/#customizing-the-kernel","text":"Now that you have built your custom Linux distribution, you can add or remove whatever you want. One of the most important parts of the build is the actual Linux kernel. You can control the kernel by running the menuconfig script, which will allow you to enable, disable or turn certain features into kernel modules. To run the menuconfig script, ensure you are in the build environment and run the following command: bitbake -c menuconfig virtual/kernel After running this command, a .config file should be generated stating all of your customizations.","title":"Customizing the Kernel"},{"location":"yocto/next-steps/#adding-packages-and-layers","text":"As stated earlier, you can visit the OpenEmbedded Layers Index to find more layers with packages you can install onto your system. Don't forget that the OpenEmbedded repository also has some layers which we haven't included yet! Once you add a layer which contains the packages you want to install to the BBLAYERS variable, you can add the following line to your local.conf file, replacing the packages below with the names of the packages you want to install. Just make sure to conserve the space before and between each of the package names. IMAGE_INSTALL_append = \" package1 package2 package3\" If you can't find a particular package, you can even create your own Yocto layer and create a recipe which will download and install that package. Just be aware that things can get a bit complicated with this method, so it is preferrable to use an existing layer if possible. While I have not found a good tutorial on how to create a layer, the following one explains very briefly how to create a layer and a recipe for a kernel module: Yocto: Create a New Layer","title":"Adding Packages and Layers"},{"location":"yocto/prerequisites/","text":"Prerequisites In order to follow this tutorial, you will need the following hardware and software components: A machine running Linux While some distributions are not supported by the Yocto project for development, you can get away with using most of them anyways. The recommended distribution is Ubuntu, however I am using Arch Linux which is currently unsupported, yet everything still works fine. You should be able to follow this tutorial if you are running Linux in a virtual machine, just make sure that you can read and write to the Micro-SD card used by the Raspberry Pi 4. You should also ensure that you have a decent amount of memory, hard drive space and CPU power available, because creating images with Yocto requires a lot of resources and can take several hours to build. I would set aside at least 50 GB of space for this project. Raspberry Pi 4 (Any model) Make sure you have a way to power the Raspberry Pi and a way to connect to it. In my experience it is much easier to connect the Raspberry Pi to a screen, keyboard and mouse than to SSH into it. Micro-SD card (> 4 GB in size) This is the storage card that will be used by the Raspberry Pi. You will need to overwrite the data on this card with your Linux distribution in order to run it on the Raspberry Pi. Micro-SD to SD card adapter Unless your PC comes with a Micro-SD card reader, you will need this adapter in order to read and write to the Micro-SD card. Make sure your computer has an SD card reader, otherwise you will need another type of adapter.","title":"Prerequisites"},{"location":"yocto/prerequisites/#prerequisites","text":"In order to follow this tutorial, you will need the following hardware and software components: A machine running Linux While some distributions are not supported by the Yocto project for development, you can get away with using most of them anyways. The recommended distribution is Ubuntu, however I am using Arch Linux which is currently unsupported, yet everything still works fine. You should be able to follow this tutorial if you are running Linux in a virtual machine, just make sure that you can read and write to the Micro-SD card used by the Raspberry Pi 4. You should also ensure that you have a decent amount of memory, hard drive space and CPU power available, because creating images with Yocto requires a lot of resources and can take several hours to build. I would set aside at least 50 GB of space for this project. Raspberry Pi 4 (Any model) Make sure you have a way to power the Raspberry Pi and a way to connect to it. In my experience it is much easier to connect the Raspberry Pi to a screen, keyboard and mouse than to SSH into it. Micro-SD card (> 4 GB in size) This is the storage card that will be used by the Raspberry Pi. You will need to overwrite the data on this card with your Linux distribution in order to run it on the Raspberry Pi. Micro-SD to SD card adapter Unless your PC comes with a Micro-SD card reader, you will need this adapter in order to read and write to the Micro-SD card. Make sure your computer has an SD card reader, otherwise you will need another type of adapter.","title":"Prerequisites"},{"location":"yocto/running-yocto/","text":"Running your Custom Linux Distribution Once you turn on your Raspberry Pi with the Linux distribution loaded into the Micro-SD card, it should boot into a virtual console asking you to log in. The system should have only one user: root . You can log into the system by entering root as the username, and leaving the password blank and pressing enter. Given that a minimal build was created, you should only really have access to the basic GNU commands. If you have reached this stage then congratulations! , you have made your own custom Linux distribution! You may notice that it is a bit bare at the moment, but the beauty of it is that you can add or remove whatever you want. It's essentially a blank canvas for you to play with!","title":"Running your Custom Linux Distribution"},{"location":"yocto/running-yocto/#running-your-custom-linux-distribution","text":"Once you turn on your Raspberry Pi with the Linux distribution loaded into the Micro-SD card, it should boot into a virtual console asking you to log in. The system should have only one user: root . You can log into the system by entering root as the username, and leaving the password blank and pressing enter. Given that a minimal build was created, you should only really have access to the basic GNU commands. If you have reached this stage then congratulations! , you have made your own custom Linux distribution! You may notice that it is a bit bare at the moment, but the beauty of it is that you can add or remove whatever you want. It's essentially a blank canvas for you to play with!","title":"Running your Custom Linux Distribution"},{"location":"yocto/setup/","text":"Setting up the Development Environment From now on, all the steps taken will assume that you are working inside your Linux machine, and that you have a working internet connection and sufficient hard drive space (at least 50 GB). Required Downloads Before anything, you will have to install the following set of packages: build-essential chrpath diffstat gawk libncurses5-dev python3-distutils texinfo lz4c zstd If you are running one of the distributions below you can run the command that is shown. For other distributions these packages may vary or may already be installed, and will need to be installed through that distribution's package manager. Ubuntu Arch Linux sudo apt install build-essential chrpath diffstat gawk libncurses5-dev python3-distutils texinfozstd liblz4-tool sudo pacman -S chrpath diffstat gawk ncurses texinfo rpcsvc-proto In order to start work on the distribution, you must first set up the foundations which you will use to build and compile everything. The first step is to create a folder where you will house your files. I decided to call my folder Yocto, and I put it in my Documents folder: \u2514\u2500 Documents/ \u2514\u2500 Yocto/ Now that you have this folder, make sure to move into the Yocto directory. In my case, I would run the following command: cd ~/Documents/Yocto Before downloading anything, you must know which release of Yocto you will be using. At the time of this writing I will be doing all demonstrations with kirkstone , however you should consult the releases page and choose the most recent Long Term Support release available. In order to avoid having to build literally everything from scratch, we will be using Poky, which I like to think of as a blank template with a lot of useful tools. Poky is stored in a Git repository which has branches for every release, so you want to download the branch for kirkstone or whichever release you are going to use. This will be a recurring theme between Yocto related repositories. This can be done by running the following command: git clone -b kirkstone git://git.yoctoproject.org/poky Next, you need to download the meta-openembedded layer, which again is a set of very helpful recipes for embedded systems. Just like with the Poky repository, you need to download the correct branch: git clone -b kirkstone git://git.openembedded.org/meta-openembedded Finally, we need a layer which contains specific recipes which will allow our distribution to function on the Raspberry Pi 4, it is not enough to just have the Poky and OpenEmbedded layers for a specific architecture. This layer is what is known as a board support package . If you are building a distribution for a board other than the Raspberry Pi 4, there is likely a Git repository somewhere on the internet with the board support package for that board. You can download the relevant branch of the repository with the following command: git clone -b kirkstone git://git.yoctoproject.org/meta-raspberrypi Your Yocto folder should now have three folders: \u2514\u2500 Documents/ \u2514\u2500 Yocto/ \u251c\u2500 meta-openembedded/ \u251c\u2500 meta-raspberrypi/ \u2514\u2500 poky/ Optional Downloads There are several other layers that can be downloaded to add more features to your Linux distribution. If this is your first time making a Yocto distribution, I would advise against adding these layers unless you know what you are doing or really require them because they will increase the amount of time it takes to build an image. You can find a list of these layers in the OpenEmbedded Layers Index . Entering the Build Environment After everything has been downloaded you will need to enter the build environment which gives you access to a bunch of Poky commands and more importantly bitbake , which is the main build tool. To start the build environment, you will have to navigate into the poky/ directory and run the following command: source oe-init-build-env This will run the oe-init-build-env script, which will launch you straight into the build environment and put you inside a directory called build/, which will be the main space where you work on your distribution. You can change the name of the build directory by adding the new name to the end of the previous command, however you should note that once the system has been built, you cannot change the name of the directory without rebuilding everything. I personally prefer the build directory to be called build/, therefore I left the previous command as-is.","title":"Setting up the Development Environment"},{"location":"yocto/setup/#setting-up-the-development-environment","text":"From now on, all the steps taken will assume that you are working inside your Linux machine, and that you have a working internet connection and sufficient hard drive space (at least 50 GB).","title":"Setting up the Development Environment"},{"location":"yocto/setup/#required-downloads","text":"Before anything, you will have to install the following set of packages: build-essential chrpath diffstat gawk libncurses5-dev python3-distutils texinfo lz4c zstd If you are running one of the distributions below you can run the command that is shown. For other distributions these packages may vary or may already be installed, and will need to be installed through that distribution's package manager. Ubuntu Arch Linux sudo apt install build-essential chrpath diffstat gawk libncurses5-dev python3-distutils texinfozstd liblz4-tool sudo pacman -S chrpath diffstat gawk ncurses texinfo rpcsvc-proto In order to start work on the distribution, you must first set up the foundations which you will use to build and compile everything. The first step is to create a folder where you will house your files. I decided to call my folder Yocto, and I put it in my Documents folder: \u2514\u2500 Documents/ \u2514\u2500 Yocto/ Now that you have this folder, make sure to move into the Yocto directory. In my case, I would run the following command: cd ~/Documents/Yocto Before downloading anything, you must know which release of Yocto you will be using. At the time of this writing I will be doing all demonstrations with kirkstone , however you should consult the releases page and choose the most recent Long Term Support release available. In order to avoid having to build literally everything from scratch, we will be using Poky, which I like to think of as a blank template with a lot of useful tools. Poky is stored in a Git repository which has branches for every release, so you want to download the branch for kirkstone or whichever release you are going to use. This will be a recurring theme between Yocto related repositories. This can be done by running the following command: git clone -b kirkstone git://git.yoctoproject.org/poky Next, you need to download the meta-openembedded layer, which again is a set of very helpful recipes for embedded systems. Just like with the Poky repository, you need to download the correct branch: git clone -b kirkstone git://git.openembedded.org/meta-openembedded Finally, we need a layer which contains specific recipes which will allow our distribution to function on the Raspberry Pi 4, it is not enough to just have the Poky and OpenEmbedded layers for a specific architecture. This layer is what is known as a board support package . If you are building a distribution for a board other than the Raspberry Pi 4, there is likely a Git repository somewhere on the internet with the board support package for that board. You can download the relevant branch of the repository with the following command: git clone -b kirkstone git://git.yoctoproject.org/meta-raspberrypi Your Yocto folder should now have three folders: \u2514\u2500 Documents/ \u2514\u2500 Yocto/ \u251c\u2500 meta-openembedded/ \u251c\u2500 meta-raspberrypi/ \u2514\u2500 poky/","title":"Required Downloads"},{"location":"yocto/setup/#optional-downloads","text":"There are several other layers that can be downloaded to add more features to your Linux distribution. If this is your first time making a Yocto distribution, I would advise against adding these layers unless you know what you are doing or really require them because they will increase the amount of time it takes to build an image. You can find a list of these layers in the OpenEmbedded Layers Index .","title":"Optional Downloads"},{"location":"yocto/setup/#entering-the-build-environment","text":"After everything has been downloaded you will need to enter the build environment which gives you access to a bunch of Poky commands and more importantly bitbake , which is the main build tool. To start the build environment, you will have to navigate into the poky/ directory and run the following command: source oe-init-build-env This will run the oe-init-build-env script, which will launch you straight into the build environment and put you inside a directory called build/, which will be the main space where you work on your distribution. You can change the name of the build directory by adding the new name to the end of the previous command, however you should note that once the system has been built, you cannot change the name of the directory without rebuilding everything. I personally prefer the build directory to be called build/, therefore I left the previous command as-is.","title":"Entering the Build Environment"}]}